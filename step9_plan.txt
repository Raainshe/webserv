Step 9: Uploads and POST Handling - Implementation Plan

Scope
- Implement multipart/form-data parsing for POST requests.
- Save uploaded files to the configured upload_store in the matched location.
- Preserve existing POST behavior for non-upload routes.

Integration Points
- Parser: add multipart parsing in src/http/request_parser.cpp where it currently returns 501 for multipart.
- Request model: extend HttpRequest to store parsed form fields and uploaded files.
- Response handler: implement saving to disk in HttpResponseHandling::handle_post_request(...) using route_result.location->upload_store.
- Routing: upload_store already available in LocationConfig and exposed via RouteResult->location.

Minimal Viable Milestone (Content-Length only; no chunked)
1) Multipart parsing (in-memory)
   - Read boundary from header: Content-Type: multipart/form-data; boundary=...
   - Split body by boundary markers: --boundary ... --boundary--
   - For each part:
     - Parse part headers (Content-Disposition required with name; optional filename)
     - If filename present => file part; else => normal form field
     - Capture raw bytes up to next boundary (handle CRLF correctly)
   - Errors: missing/invalid boundary -> 400; malformed headers -> 400.

2) HttpRequest data structures
   - Add structures and accessors:
     - struct UploadedFile { std::string fieldName; std::string filename; std::string contentType; std::string data; };
     - std::vector<UploadedFile> get_uploaded_files() const;
     - std::map<std::string, std::string> get_form_fields() const;
   - Populate these during multipart parsing.

3) Persist files in POST handler
   - In HttpResponseHandling::handle_post_request(...):
     - If route_result.location exists and location->upload_store is non-empty:
       - Ensure directory exists and is writable (create if needed where allowed; else 500 on failure).
       - Sanitize filename: strip paths, reject ".." and control characters.
       - Deduplicate names: name.ext, name(1).ext, etc., if file exists.
       - Write bytes to disk.
       - Respond 201 Created with a minimal JSON or text summary of saved files.
     - If not multipart, keep current behavior (200 with "POST request received successfully!") or return 415 for /upload (optional policy).

4) Limits and errors
   - client_max_body_size already enforced in src/networking/event_loop.cpp (both during and after parsing). No extra work needed here.
   - Transfer-Encoding: chunked remains 501 for now (implemented later with Step 8).

Follow-ups (later)
- Streamed multipart parsing to avoid large memory use.
- Support chunked + multipart once chunked decoding is added.
- Configurable temp directory; move to upload_store after write completes.
- Return Location header per created resource; stronger MIME checks.

Test Plan
- Existing POST (non-upload):
  - curl -s -X POST -H 'Host: localhost' http://localhost:8080/
  - Expect 200 and existing message.
- Single file upload:
  - curl -s -F "file=@test_files/images/photo1.jpg" http://localhost:8080/upload/
  - Verify file appears under test_files/uploads/ and server returns 201.
- Multiple files + fields:
  - curl -s -F "f1=@test_files/images/photo1.jpg" -F "f2=@test_files/images/photo2.jpg" -F "note=hello" http://localhost:8080/upload/
  - Verify both files saved; response lists them.
- Method restrictions (405) and 413 still pass via existing tests.
- Bad multipart (missing boundary, malformed headers) -> 400.

Key Decisions
- Keep Step 9 simple and safe: parse multipart fully in memory, bounded by client_max_body_size.
- Do not couple disk I/O to the parser; saving happens in the POST handler based on routing (upload_store).
